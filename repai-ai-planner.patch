diff --git a/utils/repAIPlanner.js b/utils/repAIPlanner.js
new file mode 100644
--- /dev/null
+++ b/utils/repAIPlanner.js
@@ -0,0 +1,282 @@
+// utils/repAIPlanner.js
+// Ship-ready interim exercise planner with a stable I/O interface.
+// Drop-in now; swap internals later for GPT without changing callers.
+
+export function generatePlan(input) {
+  const now = Date.now();
+  const {
+    history = [],
+    goals = 'hypertrophy',
+    split = 'full',
+    timeBudgetMin = 45,
+    equipment = ['barbell', 'dumbbell', 'machine', 'cable', 'bodyweight'],
+    catalog = DEFAULT_CATALOG,
+    constraints = {},
+    vitals = {},
+    settings = {},
+    seed = now
+  } = input || {};
+
+  const rnd = mulberry32(seed >>> 0);
+
+  const units = settings.units || inferUnits(history) || 'lb';
+  const plateIncLb = clamp(settings.plateIncrementLb ?? 5, 1, 10);
+  const plateIncKg = clamp(settings.plateIncrementKg ?? 2.5, 0.5, 5);
+  const maxHeavyHinges7d = settings.maxHeavyHingesPer7d ?? 1;
+
+  // 1) Signals from history
+  const perGroup = aggregateHistory(history);
+  const hingesIn7d = perGroup.pattern7dCount['hinge'] || 0;
+
+  // 2) Choose priority muscle groups for today (split + fairness)
+  const priorityGroups = pickGroupsForSplit(split);
+  priorityGroups.sort((a, b) => {
+    const gapA = perGroup.gapDays[a] ?? 999, gapB = perGroup.gapDays[b] ?? 999;
+    if (gapA !== gapB) return gapB - gapA;
+    const volA = perGroup.vol7[a] ?? 0, volB = perGroup.vol7[b] ?? 0;
+    return volA - volB;
+  });
+
+  // 3) Set budget based on goals, readiness, time
+  const readiness = clamp(vitals.readiness ?? blendReadiness(vitals), 0, 1);
+  const baseSets = goals === 'strength' ? 22 : goals === 'endurance' ? 18 : 24;
+  const setBudget = scaleByReadinessAndTime(baseSets, readiness, timeBudgetMin, goals);
+
+  // 4) Build and filter exercise pool
+  const pool = buildExercisePool(catalog, equipment, constraints, vitals);
+
+  // 5) Select exercises (compounds first, then accessories)
+  const picks = chooseExercises(pool, priorityGroups, goals, rnd, {
+    hingesIn7d,
+    maxHeavyHinges7d,
+    lastUsedByExercise: perGroup.lastUsedByExercise
+  });
+
+  // 6) Dose sets/reps and progress weights
+  const scheme = repScheme(goals);
+  const plateInc = units === 'kg' ? plateIncKg : plateIncLb;
+  const plannedBlocks = picks.map(ex => {
+    const last = perGroup.lastPerf[ex.id] || null;
+    const target = nextLoadTarget(ex, last, scheme, plateInc, units);
+    const sets = Array.from({ length: target.sets }).map(() => ({
+      id: uid(rnd), weight: target.weight, reps: target.reps
+    }));
+    return { id: uid(rnd), exercise: ex, sets };
+  });
+
+  // 7) Trim to budget (prioritize compounds / first groups)
+  const trimmed = trimToBudget(plannedBlocks, setBudget, priorityGroups);
+
+  // 8) Safety: avoid duplicates & excessive pattern overlap
+  const safe = deDuplicatePatterns(trimmed);
+
+  // 9) Smart session name
+  const name = smartName(split, goals, priorityGroups);
+
+  return {
+    id: uid(rnd),
+    name,
+    createdAt: now,
+    units,
+    blocks: safe
+  };
+}
+
+/* --------------------------------- Helpers -------------------------------- */
+function e1RM(weight, reps) { const w = Number(weight)||0, r = Number(reps)||0; return w>0&&r>0 ? w*(1+r/30) : 0; }
+function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
+function roundToPlate(w, inc) { if (!isFinite(w)) return 0; return Math.max(0, Math.round(w/inc)*inc); }
+function uid(rnd=Math.random){ const s=()=>Math.floor(rnd()*0xffffffff).toString(16).padStart(8,'0'); return `${s()}-${s()}`; }
+function mulberry32(a){ return function(){ let t=(a+=0x6d2b79f5); t=Math.imul(t^(t>>>15), t|1); t^=t+Math.imul(t^(t>>>7), t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
+function inferUnits(history){ for (const w of history||[]) if (w?.units==='kg'||w?.units==='lb') return w.units; return null; }
+function blendReadiness(v){ const parts=[v.readiness,v.sleepQuality,v.energy].filter(x=>typeof x==='number'&&isFinite(x)); if(!parts.length) return 0.8; return clamp(parts.reduce((a,b)=>a+b,0)/parts.length,0,1); }
+function scaleByReadinessAndTime(base, ready, timeMin, goals){
+  const perSetSec = goals==='strength' ? 180 : goals==='endurance' ? 75 : 105;
+  const maxSetsByTime = Math.floor((timeMin*60)/perSetSec);
+  const scaled = Math.round(base * (0.7 + 0.45*ready)); // ~0.7x..1.15x
+  return clamp(scaled, Math.min(12,maxSetsByTime), Math.max(8,maxSetsByTime));
+}
+function pickGroupsForSplit(split){
+  switch(split){
+    case 'upper': return ['Chest','Back','Shoulders','Arms'];
+    case 'lower': return ['Legs','Abs'];
+    case 'push':  return ['Chest','Shoulders','Arms'];
+    case 'pull':  return ['Back','Arms'];
+    case 'legs':  return ['Legs','Abs'];
+    case 'full':
+    default:      return ['Chest','Back','Shoulders','Arms','Legs','Abs'];
+  }
+}
+function aggregateHistory(history){
+  const now=Date.now(), vol7=Object.create(null), lastDate=Object.create(null), lastPerf=Object.create(null), lastUsedByExercise=Object.create(null), pattern7dCount=Object.create(null);
+  for (const w of history||[]) for (const b of w?.blocks||[]) { const ex=b?.exercise||{}; const group=ex.muscleGroup; const pattern=ex.pattern;
+    for (const s of b?.sets||[]) { const done=Number(s?.completedAt)||0; const weight=Number(s?.weight)||0; const reps=Number(s?.reps)||0;
+      if (done>0 && weight>0 && reps>0){
+        if (now - done <= 7*86400000){ vol7[group]=(vol7[group]||0)+weight*reps; if(pattern) pattern7dCount[pattern]=(pattern7dCount[pattern]||0)+1; }
+        lastDate[group]=Math.max(lastDate[group]||0, done);
+        const key=ex.id; const best=lastPerf[key]?.bestSet||null; const e=e1RM(weight,reps);
+        if (!best || e>best.e1RM) lastPerf[key]={ bestSet:{weight,reps,e1RM:e}, at:done };
+        lastUsedByExercise[key]=done;
+      }
+    }
+  }
+  const gapDays=Object.create(null); for (const g of ['Chest','Back','Shoulders','Arms','Legs','Abs']) gapDays[g]=lastDate[g]?Math.floor((now-lastDate[g])/86400000):999;
+  return { vol7, gapDays, lastPerf, lastUsedByExercise, pattern7dCount };
+}
+function buildExercisePool(catalog,equipment,constraints,vitals){
+  const allowed=new Set(equipment); const avoid=new Set((constraints.avoidMuscles||[]).map(cap));
+  const target=new Set((constraints.targetMuscles||[]).map(cap)); const sore=vitals.sorenessByGroup||{};
+  const pool=catalog.filter(ex=>{
+    if (ex?.equipment && !allowed.has(ex.equipment)) return false;
+    if (avoid.has(cap(ex.muscleGroup))) return false;
+    if (constraints.injuries?.includes('lower_back') && ex.pattern==='hinge') return false;
+    return true;
+  }).map(ex=>{
+    const mg=cap(ex.muscleGroup); const sorePenalty=clamp(Number(sore[mg]||0),0,1); const targetBonus = target.size ? (target.has(mg)?0.25:-0.1) : 0;
+    return { ...ex, __score: 1 - 0.4*sorePenalty + targetBonus, pattern: ex.pattern || inferPattern(ex) };
+  });
+  return pool;
+}
+function cap(s){ if(!s) return ''; return String(s).charAt(0).toUpperCase()+String(s).slice(1).toLowerCase(); }
+function inferPattern(ex){ const n=(ex?.name||'').toLowerCase();
+  if (n.includes('deadlift')||n.includes('rdl')||n.includes('hinge')) return 'hinge';
+  if (n.includes('squat')||n.includes('lunge')||n.includes('split squat')||n.includes('leg press')) return 'squat';
+  if (n.includes('row')) return 'horizontal_pull';
+  if (n.includes('pulldown')||n.includes('pull-up')) return 'vertical_pull';
+  if (n.includes('bench')||n.includes('press')) { if (n.includes('overhead')||n.includes('shoulder')) return 'vertical_press'; return 'horizontal_press'; }
+  return 'isolation';
+}
+function chooseExercises(pool, priorityGroups, goals, rnd, ctx){
+  const picks=[], chosen=new Set();
+  const compounds=pool.filter(x=>x.pattern && x.pattern!=='isolation');
+  const accessories=pool.filter(x=>x.pattern==='isolation');
+  const perGComp=Object.create(null), perGAcc=Object.create(null);
+  for (const ex of compounds){ const g=cap(ex.muscleGroup); (perGComp[g] ||= []).push(ex); }
+  for (const ex of accessories){ const g=cap(ex.muscleGroup); (perGAcc[g] ||= []).push(ex); }
+  const allowHinge = (ctx.hingesIn7d||0) < (ctx.maxHeavyHinges7d||1);
+  for (const g of priorityGroups){
+    const list=(perGComp[g]||[]).filter(ex=>allowHinge || ex.pattern!=='hinge');
+    if (!list.length) continue;
+    const ex=weightedPick(list,rnd);
+    if (!chosen.has(ex.id)){ picks.push(ex); chosen.add(ex.id); }
+  }
+  const patternsNeeded=['horizontal_press','vertical_press','horizontal_pull','vertical_pull','squat','hinge'];
+  for (const p of patternsNeeded){
+    if (p==='hinge' && !allowHinge) continue;
+    if (!picks.some(ex=>ex.pattern===p)){
+      const cands=compounds.filter(ex=>ex.pattern===p && !chosen.has(ex.id));
+      if (cands.length){ const ex=weightedPick(cands,rnd); picks.push(ex); chosen.add(ex.id); }
+    }
+  }
+  for (const g of priorityGroups){
+    const cands=(perGAcc[g]||[]).filter(ex=>!chosen.has(ex.id));
+    if (cands.length){ const acc=weightedPick(cands,rnd); picks.push(acc); chosen.add(acc.id); }
+  }
+  while (picks.length>6) picks.pop();
+  return picks;
+}
+function weightedPick(arr,rnd){ if(!arr.length) return null; const scores=arr.map(x=>Math.max(0.01,Number(x.__score||1))); const sum=scores.reduce((a,b)=>a+b,0); let r=rnd()*sum; for(let i=0;i<arr.length;i++){ r-=scores[i]; if(r<=0) return arr[i]; } return arr[arr.length-1]; }
+function repScheme(goals){ switch(goals){ case 'strength': return { setsPrimary:4, setsAccessory:3, repsMin:3, repsMax:6, restSec:180, loadBumpPct:0.025 }; case 'endurance': return { setsPrimary:3, setsAccessory:2, repsMin:12, repsMax:20, restSec:75, loadBumpPct:0.02 }; default: return { setsPrimary:3, setsAccessory:2, repsMin:8, repsMax:12, restSec:105, loadBumpPct:0.02 }; } }
+function nextLoadTarget(ex,last,scheme,plateInc,units){
+  const isPrimary = ex.pattern && ex.pattern!=='isolation';
+  const sets = isPrimary ? scheme.setsPrimary : scheme.setsAccessory;
+  const repMin=scheme.repsMin, repMax=scheme.repsMax;
+  let targetReps = Math.round((repMin+repMax)/2);
+  let weight = baseStartingWeight(ex, units);
+  if (last?.bestSet){
+    const lw=last.bestSet.weight, lr=last.bestSet.reps;
+    const hitTop = lr >= repMax*0.66;
+    if (hitTop){ weight = roundToPlate(lw*(1+scheme.loadBumpPct), plateInc); targetReps = Math.max(repMin, lr-1); }
+    else { weight = roundToPlate(lw, plateInc); targetReps = Math.min(repMax, Math.max(repMin, lr+1)); }
+  }
+  return { sets, reps: targetReps, weight };
+}
+function baseStartingWeight(ex, units){
+  const lb = { barbell:{Chest:135,Back:0,Shoulders:95,Legs:185,Arms:0,Abs:0}, dumbbell:{Chest:55,Back:60,Shoulders:40,Legs:0,Arms:25,Abs:0}, machine:{Chest:80,Back:100,Shoulders:60,Legs:180,Arms:50,Abs:30}, cable:{Chest:35,Back:0,Shoulders:0,Legs:0,Arms:40,Abs:35}, bodyweight:{Chest:0,Back:0,Shoulders:0,Legs:0,Arms:0,Abs:0} };
+  const base = lb[ex.equipment]?.[ex.muscleGroup] ?? 0;
+  return units==='kg' ? Math.round(base/2.2046) : base;
+}
+function trimToBudget(blocks,setBudget,priorityGroups){
+  const out=[], byG=Object.create(null); let sets=0;
+  for (const b of blocks) (byG[cap(b.exercise.muscleGroup)] ||= []).push(b);
+  for (const g of priorityGroups){
+    const list=(byG[g]||[]).sort((a,b)=>importance(b)-importance(a));
+    if (list.length){ const pick=list.shift(); out.push(pick); sets+=pick.sets.length; byG[g]=list; }
+  }
+  const rest=[]; Object.values(byG).forEach(list=>list?.forEach(b=>rest.push(b)));
+  rest.sort((a,b)=>importance(b)-importance(a));
+  for (const b of rest){ if (sets + b.sets.length > setBudget) continue; out.push(b); sets+=b.sets.length; }
+  while (sets>setBudget && out.length){ const idx=out.findIndex(b=>b.exercise.pattern==='isolation'); const drop=idx>=0?idx:out.length-1; sets-=out[drop].sets.length; out.splice(drop,1); }
+  return out;
+}
+function importance(block){ const p=block.exercise.pattern; const g=cap(block.exercise.muscleGroup); const comp=(p && p!=='isolation')?2:0; const small=(g==='Shoulders'||g==='Arms'||g==='Abs')?0.15:0; return comp+small+1; }
+function deDuplicatePatterns(blocks){ const seen=new Set(), out=[]; for(const b of blocks){ const key=`${b.exercise.pattern}:${b.exercise.muscleGroup}`; if (seen.has(key)){ if (b.exercise.pattern==='isolation') out.push(b); continue; } seen.add(key); out.push(b); } return out; }
+function smartName(split,goals,groups){ const label={hypertrophy:'Hypertrophy',strength:'Strength',endurance:'Endurance'}[goals]||'Training'; const g=(groups||[]).slice(0,2).join('/'); const s=split==='full'?'Full Body':cap(split); return `${s} – ${label}${g?` (${g})`:''}`; }
+
+const DEFAULT_CATALOG = [
+  { id:'ex_bb_back_squat', name:'Barbell Back Squat', muscleGroup:'Legs', equipment:'barbell', pattern:'squat' },
+  { id:'ex_bb_deadlift',   name:'Barbell Deadlift',   muscleGroup:'Back', equipment:'barbell', pattern:'hinge' },
+  { id:'ex_bb_bench',      name:'Barbell Bench Press',muscleGroup:'Chest',equipment:'barbell', pattern:'horizontal_press' },
+  { id:'ex_bb_ohp',        name:'Barbell Overhead Press', muscleGroup:'Shoulders', equipment:'barbell', pattern:'vertical_press' },
+  { id:'ex_db_press',      name:'Dumbbell Bench Press',muscleGroup:'Chest',equipment:'dumbbell', pattern:'horizontal_press' },
+  { id:'ex_db_sh_press',   name:'Dumbbell Shoulder Press', muscleGroup:'Shoulders', equipment:'dumbbell', pattern:'vertical_press' },
+  { id:'ex_lat_pulldown',  name:'Lat Pulldown',       muscleGroup:'Back', equipment:'machine', pattern:'vertical_pull' },
+  { id:'ex_seated_row',    name:'Seated Row',         muscleGroup:'Back', equipment:'machine', pattern:'horizontal_pull' },
+  { id:'ex_cable_fly',     name:'Cable Fly',          muscleGroup:'Chest',equipment:'cable',   pattern:'isolation' },
+  { id:'ex_lat_raise',     name:'Lateral Raise',      muscleGroup:'Shoulders',equipment:'dumbbell', pattern:'isolation' },
+  { id:'ex_triceps_pd',    name:'Triceps Pressdown',  muscleGroup:'Arms', equipment:'cable',   pattern:'isolation' },
+  { id:'ex_db_curl',       name:'Dumbbell Curl',      muscleGroup:'Arms', equipment:'dumbbell',pattern:'isolation' },
+  { id:'ex_ham_curl',      name:'Hamstring Curl',     muscleGroup:'Legs', equipment:'machine', pattern:'isolation' },
+  { id:'ex_leg_ext',       name:'Leg Extension',      muscleGroup:'Legs', equipment:'machine', pattern:'isolation' },
+  { id:'ex_calf_raise',    name:'Standing Calf Raise',muscleGroup:'Legs', equipment:'machine', pattern:'isolation' },
+];
diff --git a/utils/loadTestData.js b/utils/loadTestData.js
new file mode 100644
--- /dev/null
+++ b/utils/loadTestData.js
@@ -0,0 +1,191 @@
+// utils/loadTestData.js
+import AsyncStorage from '@react-native-async-storage/async-storage';
+const WORKOUTS_KEY = 'rnsteps.workouts.v1';
+const TEMPLATES_KEY = 'workout:templates';
+
+const MG = ['Chest','Back','Shoulders','Arms','Legs','Abs'];
+const NOW = Date.now();
+
+function uid() { return 'xxxxxxxx-xxxx'.replace(/[x]/g, () => Math.floor(Math.random()*16).toString(16)); }
+function rand(min, max) { return Math.floor(min + Math.random()*(max-min+1)); }
+function pick(arr) { return arr[rand(0, arr.length-1)]; }
+function daysAgo(n){ return NOW - n*24*60*60*1000; }
+function roundToPlate(w, units='lb'){ const inc = units==='kg'?2.5:5; return Math.round((w||0)/inc)*inc; }
+
+const CATALOG = [
+  { id:'ex_bb_bench', name:'Barbell Bench Press', muscleGroup:'Chest', equipment:'barbell', icon:'bench' },
+  { id:'ex_db_press', name:'Dumbbell Bench Press', muscleGroup:'Chest', equipment:'dumbbell', icon:'db' },
+  { id:'ex_cable_fly', name:'Cable Fly', muscleGroup:'Chest', equipment:'cable', icon:'fly' },
+  { id:'ex_pulldown', name:'Lat Pulldown', muscleGroup:'Back', equipment:'machine', icon:'lat' },
+  { id:'ex_row', name:'Seated Row', muscleGroup:'Back', equipment:'machine', icon:'row' },
+  { id:'ex_db_row', name:'DB Row', muscleGroup:'Back', equipment:'dumbbell', icon:'dbrow' },
+  { id:'ex_ohp', name:'Barbell Overhead Press', muscleGroup:'Shoulders', equipment:'barbell', icon:'ohp' },
+  { id:'ex_db_sh', name:'DB Shoulder Press', muscleGroup:'Shoulders', equipment:'dumbbell', icon:'db' },
+  { id:'ex_lat_raise', name:'Lateral Raise', muscleGroup:'Shoulders', equipment:'dumbbell', icon:'lat' },
+  { id:'ex_curl', name:'DB Curl', muscleGroup:'Arms', equipment:'dumbbell', icon:'curl' },
+  { id:'ex_triceps', name:'Cable Pressdown', muscleGroup:'Arms', equipment:'cable', icon:'tri' },
+  { id:'ex_hammer', name:'Hammer Curl', muscleGroup:'Arms', equipment:'dumbbell', icon:'curl' },
+  { id:'ex_squat', name:'Back Squat', muscleGroup:'Legs', equipment:'barbell', icon:'squat' },
+  { id:'ex_rdl', name:'Romanian Deadlift', muscleGroup:'Legs', equipment:'barbell', icon:'rdl' },
+  { id:'ex_legpress', name:'Leg Press', muscleGroup:'Legs', equipment:'machine', icon:'press' },
+  { id:'ex_legext', name:'Leg Extension', muscleGroup:'Legs', equipment:'machine', icon:'ext' },
+  { id:'ex_hamcurl', name:'Hamstring Curl', muscleGroup:'Legs', equipment:'machine', icon:'curl' },
+  { id:'ex_plank', name:'Plank', muscleGroup:'Abs', equipment:'bodyweight', icon:'plank' },
+  { id:'ex_cablecr', name:'Cable Crunch', muscleGroup:'Abs', equipment:'cable', icon:'crunch' },
+  { id:'ex_hangleg', name:'Hanging Leg Raise', muscleGroup:'Abs', equipment:'bodyweight', icon:'leg' },
+];
+
+function baselineWeight(ex, units) {
+  const lb = {
+    barbell: { Chest: 135, Back: 0,  Shoulders: 95,  Legs: 185, Arms: 0, Abs: 0 },
+    dumbbell:{ Chest: 55,  Back: 60, Shoulders: 40,  Legs: 0,   Arms: 25, Abs: 0 },
+    machine: { Chest: 80,  Back: 100,Shoulders: 60,  Legs: 180, Arms: 50, Abs: 30 },
+    cable:   { Chest: 35,  Back: 0,  Shoulders: 0,   Legs: 0,   Arms: 40, Abs: 35 },
+    bodyweight: { Chest:0, Back:0, Shoulders:0, Legs:0, Arms:0, Abs:0 }
+  };
+  const base = lb[ex.equipment]?.[ex.muscleGroup] ?? 0;
+  return units==='kg' ? Math.round(base/2.2046) : base;
+}
+
+function makeSet(ex, units, intensity=1){
+  const repsByGroup = { Chest:[8,12], Back:[8,12], Shoulders:[8,12], Arms:[10,15], Legs:[6,12], Abs:[12,20] };
+  const [minR,maxR] = repsByGroup[ex.muscleGroup] || [8,12];
+  const reps = rand(minR,maxR);
+  let w = baselineWeight(ex, units);
+  w = roundToPlate(w * (0.9 + Math.random()*0.2) * intensity, units);
+  return { id: uid(), weight: w, reps, completedAt: 0 };
+}
+
+function makeBlock(ex, units, sets=3, startTime){
+  const block = { id: uid(), exercise: ex, sets: [] };
+  let t = startTime;
+  for (let i=0;i<sets;i++){
+    const s = makeSet(ex, units, 0.95 + i*0.03);
+    t += 90_000 + rand(-20_000, 20_000);
+    s.completedAt = t;
+    block.sets.push(s);
+  }
+  return block;
+}
+
+function sessionFor(groups, units, dayOffset){
+  const startedAt = daysAgo(dayOffset) + rand(18_00_000, 21_00_000);
+  let t = startedAt;
+  const picks = [];
+  groups.forEach(g => {
+    const comp = CATALOG.filter(e => e.muscleGroup===g && (e.equipment==='barbell' || e.equipment==='machine' || e.name.includes('Press') || e.name.includes('Row')));
+    const acc  = CATALOG.filter(e => e.muscleGroup===g && !comp.includes(e));
+    const exs = [];
+    if (comp.length) exs.push(pick(comp));
+    if (Math.random()<0.6 && comp.length>1) exs.push(pick(comp.filter(e=>e.id!==exs[0].id)));
+    if (acc.length)  exs.push(pick(acc));
+    exs.forEach(ex => {
+      const sets = ex.muscleGroup==='Legs' ? rand(3,4) : rand(2,4);
+      picks.push(makeBlock(ex, units, sets, t));
+      t += sets*(100_000 + rand(30_000,60_000));
+    });
+  });
+  const finishedAt = t;
+  return { id: uid(), title: `${groups.join('/') } Session`, units, startedAt, finishedAt, blocks: picks };
+}
+
+function planCalendar() {
+  const days = [];
+  const order = [ ['Push'], ['Pull'], ['Legs'], ['Upper'], ['Lower'], ['Full'] ];
+  for (let d=20; d>=0; d--){
+    const o = order[d % order.length][0].toLowerCase();
+    if (o==='push')      days.push(['Chest','Shoulders','Arms']);
+    else if (o==='pull') days.push(['Back','Arms']);
+    else if (o==='legs') days.push(['Legs','Abs']);
+    else if (o==='upper')days.push(['Chest','Back','Shoulders','Arms']);
+    else if (o==='lower')days.push(['Legs','Abs']);
+    else                 days.push(['Chest','Back','Legs','Shoulders','Arms','Abs'].filter(()=>Math.random()<0.5));
+  }
+  const counts = Object.fromEntries(MG.map(g=>[g,0]));
+  days.forEach(gs => gs.forEach(g => counts[g]++));
+  MG.forEach(g => { while (counts[g] < 3) { days.push([g]); counts[g]++; } });
+  return days;
+}
+
+export async function generateTestData({ units='lb' } = {}) {
+  const cal = planCalendar();
+  const workouts = cal.map((groups, idx) => sessionFor(groups, units, cal.length-idx));
+  return workouts;
+}
+
+export async function loadTestData({ units='lb', overwrite=true, includeTemplates=true } = {}) {
+  const workouts = await generateTestData({ units });
+  if (!overwrite) {
+    const raw = await AsyncStorage.getItem(WORKOUTS_KEY);
+    const existing = raw ? JSON.parse(raw) : [];
+    workouts.push(...existing);
+  }
+  await AsyncStorage.setItem(WORKOUTS_KEY, JSON.stringify(workouts));
+
+  if (includeTemplates) {
+    const templates = [
+      {
+        id: uid(), name: 'Push – Hypertrophy', createdAt: NOW - 10*86400000, units,
+        blocks: [
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_db_press'), sets:[{id:uid(),weight: roundToPlate(60,units), reps:10},{id:uid(),weight: roundToPlate(60,units), reps:10},{id:uid(),weight: roundToPlate(60,units), reps:8}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_db_sh'),   sets:[{id:uid(),weight: roundToPlate(40,units), reps:10},{id:uid(),weight: roundToPlate(40,units), reps:9}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_triceps'), sets:[{id:uid(),weight: roundToPlate(40,units), reps:12},{id:uid(),weight: roundToPlate(40,units), reps:12}] },
+        ]
+      },
+      {
+        id: uid(), name: 'Pull – Back Focus', createdAt: NOW - 9*86400000, units,
+        blocks: [
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_pulldown'), sets:[{id:uid(),weight: roundToPlate(110,units), reps:10},{id:uid(),weight: roundToPlate(110,units), reps:9}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_row'), sets:[{id:uid(),weight: roundToPlate(100,units), reps:10},{id:uid(),weight: roundToPlate(100,units), reps:10}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_curl'),   sets:[{id:uid(),weight: roundToPlate(25,units), reps:12},{id:uid(),weight: roundToPlate(25,units), reps:10}] },
+        ]
+      },
+      {
+        id: uid(), name: 'Lower – Squat + Hinge', createdAt: NOW - 8*86400000, units,
+        blocks: [
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_squat'),    sets:[{id:uid(),weight: roundToPlate(185,units), reps:6},{id:uid(),weight: roundToPlate(185,units), reps:6},{id:uid(),weight: roundToPlate(185,units), reps:5}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_rdl'),      sets:[{id:uid(),weight: roundToPlate(155,units), reps:8},{id:uid(),weight: roundToPlate(155,units), reps:8}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_legext'),   sets:[{id:uid(),weight: roundToPlate(90,units), reps:12},{id:uid(),weight: roundToPlate(90,units), reps:12}] },
+          { id: uid(), exercise: CATALOG.find(e=>e.id==='ex_hamcurl'),  sets:[{id:uid(),weight: roundToPlate(70,units), reps:12}] },
+        ]
+      }
+    ];
+    await AsyncStorage.setItem(TEMPLATES_KEY, JSON.stringify(templates));
+  }
+  return { count: workouts.length };
+}
+
diff --git a/screens/PreviewRecommended.js b/screens/PreviewRecommended.js
new file mode 100644
--- /dev/null
+++ b/screens/PreviewRecommended.js
@@ -0,0 +1,59 @@
+// screens/PreviewRecommended.js
+import React from 'react';
+import { View, Text, FlatList, Pressable } from 'react-native';
+import Card from '../components/ui/Card';
+import { palette, spacing } from '../theme';
+
+export default function PreviewRecommended({ route, navigation }) {
+  const plan = route.params?.plan;
+  if (!plan) {
+    return (
+      <View style={{ flex:1, padding: spacing(2) }}>
+        <Card style={{ padding: spacing(2) }}>
+          <Text style={{ color: palette.text, fontWeight: '900', fontSize: 18 }}>Couldn’t build a plan.</Text>
+          <Text style={{ color: palette.sub, marginTop: 6 }}>Try loading test data from Setup, then retry.</Text>
+        </Card>
+      </View>
+    );
+  }
+
+  return (
+    <View style={{ flex:1, padding: spacing(2) }}>
+      <Card style={{ padding: spacing(2) }}>
+        <Text style={{ fontSize: 18, fontWeight: '900', color: palette.text }}>{plan.name}</Text>
+        <Text style={{ color: palette.sub, marginTop: 4 }}>Units: {plan.units}</Text>
+      </Card>
+
+      <FlatList
+        style={{ marginTop: spacing(1) }}
+        data={plan.blocks}
+        keyExtractor={(b) => b.id}
+        renderItem={({ item: b }) => (
+          <Card style={{ padding: spacing(1.5), marginBottom: spacing(1) }}>
+            <Text style={{ fontWeight: '800', color: palette.text }}>{b.exercise.name}</Text>
+            <Text style={{ color: palette.sub }}>{b.exercise.muscleGroup} • {b.exercise.pattern || '–'}</Text>
+            <Text style={{ marginTop: 4, color: palette.text }}>
+              {b.sets.map(s => `${s.weight}${plan.units}×${s.reps}`).join('  ·  ')}
+            </Text>
+          </Card>
+        )}
+      />
+
+      <Pressable
+        onPress={() => {
+          const workout = {
+            id: `wk_${Date.now()}`,
+            title: plan.name,
+            startedAt: Date.now(),
+            units: plan.units,
+            blocks: plan.blocks.map(b => ({
+              id: `b_${b.id}`,
+              exercise: b.exercise,
+              sets: b.sets.map(s => ({ id: `s_${s.id}`, weight: s.weight, reps: s.reps }))
+            }))
+          };
+          navigation.navigate('TrackWorkout', { workout, source: 'ai_plan' });
+        }}
+        style={{ backgroundColor: '#6a5cff', borderRadius: 12, padding: 14, alignItems: 'center', marginTop: spacing(1) }}
+        accessibilityLabel="Start this plan"
+      >
+        <Text style={{ color: 'white', fontWeight: '900' }}>Start this plan</Text>
+      </Pressable>
+    </View>
+  );
+}
diff --git a/screens/SetupScreen.js b/screens/SetupScreen.js
--- a/screens/SetupScreen.js
+++ b/screens/SetupScreen.js
@@ -1,16 +1,17 @@
-import React, { useEffect, useState } from 'react';
+import React, { useEffect, useState, useCallback } from 'react';
 import {
   ScrollView,
   View,
   Text,
   Alert,
   Share,
   Platform,
   Modal,
   Pressable,
   TextInput,
   StyleSheet,
   Switch,
 } from 'react-native';
+import { useNavigation } from '@react-navigation/native';
 import * as FileSystem from 'expo-file-system';
 import AsyncStorage from '@react-native-async-storage/async-storage';
 
@@ -18,9 +19,11 @@
 import GradientButton from '../components/ui/GradientButton';
 import { palette, spacing, layout } from '../theme';
 import { getAllWorkouts } from '../store/workoutStore';
+import { loadTestData } from '../utils/loadTestData';
 
 // ---------- constants (settings) ----------
 const SETTINGS_KEY = 'settings:training';
 
 // ---------- helpers (export) ----------
 const isCompleted = (s) =>
@@ -173,7 +176,9 @@
 }
 
 // ---------- screen ----------
 export default function SetupScreen() {
+  const navigation = useNavigation();
   const [busy, setBusy] = useState(false);
   const [lastExportInfo, setLastExportInfo] = useState(null);
 
   // Delete modal
@@ -185,6 +190,7 @@
 
   // Training settings
   const [plateRounding, setPlateRounding] = useState('lb5'); // 'lb5' | 'kg2.5'
   const [adoptRestHints, setAdoptRestHints] = useState(true);
+  const [toast, setToast] = useState('');
 
   // Load persisted settings
   useEffect(() => {
@@ -287,8 +293,47 @@
     }
   }
 
-  return (
-    <ScrollView
+  /** Tiny inline toast (no deps) */
+  function TinyToast({ message, visible }) {
+    if (!visible) return null;
+    return (
+      <View
+        pointerEvents="none"
+        style={{
+          position: 'absolute',
+          left: 16,
+          right: 16,
+          bottom: 24,
+          paddingVertical: 10,
+          paddingHorizontal: 14,
+          borderRadius: 10,
+          backgroundColor: 'rgba(17,24,39,0.92)',
+        }}
+      >
+        <Text style={{ color: 'white', fontWeight: '700', fontSize: 12 }}>{message}</Text>
+      </View>
+    );
+  }
+
+  // --- NEW: load test data + deep link to Progress ---
+  const onLoadTestData = useCallback(async () => {
+    try {
+      setBusy(true);
+      const { count } = await loadTestData({ units: 'lb', overwrite: true, includeTemplates: true });
+      // transient toast
+      setToast(`Loaded ${count} workouts + templates`);
+      setTimeout(() => setToast(''), 2000);
+      Alert.alert('Test data loaded', `${count} workouts + templates added.`, [
+        { text: 'Stay here', style: 'cancel' },
+        { text: 'View Progress', onPress: () => navigation.navigate('Progress') },
+      ]);
+    } catch (e) {
+      Alert.alert('Error', String(e?.message || e));
+    } finally {
+      setBusy(false);
+    }
+  }, [navigation]);
+
+  return (
+    <View style={{ flex: 1, backgroundColor: palette.bg }}>
+    <ScrollView
       style={{ flex: 1, backgroundColor: palette.bg }}
       contentContainerStyle={{
         paddingHorizontal: layout.screenHMargin,
         paddingTop: spacing(2),
         paddingBottom: spacing(4),
@@ -390,6 +435,18 @@
           accessibilityLabel="Delete all data"
         >
           <Text style={styles.dangerBtnText}>Delete All Data</Text>
         </Pressable>
+
+        {/* NEW: Load test data (directly below delete) */}
+        <View style={{ height: spacing(1) }} />
+        <GradientButton
+          title={busy ? 'Loading…' : 'Load test data'}
+          onPress={onLoadTestData}
+          disabled={busy}
+          colors={['#10b981', '#059669']}
+        />
+        <Text style={{ color: palette.sub, marginTop: 6, fontSize: 12 }}>
+          Loads ~3+ sessions per muscle group over ~3 weeks, plus a few templates.
+        </Text>
       </Card>
 
       {/* Confirm Delete Modal */}
@@ -428,7 +485,10 @@
         </View>
       </Modal>
-    </ScrollView>
+    </ScrollView>
+    {/* Inline toast */}
+    <TinyToast message={toast} visible={!!toast} />
+    </View>
   );
 }
 

